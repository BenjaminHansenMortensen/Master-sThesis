\section{Oblivious Random Access Machine}
\label{sec:oram}
%\addcontentsline{toc}{section}{Oblivious Random Access Machine}

Rafail Ostrovsky and Oded Goldreich introduced \acrshort{oram} \cite{STOC:Goldreich87, STOC:Ostrovsky90, GolOst96}, and its primary functionality is that it hides the access pattern of a \acrshort{cpu} on the \acrshort{ram}. At first glance, this might not seem relatable to our problem, but instead of thinking about a \acrshort{cpu} accessing \acrshort{ram} in the modern day, we think of a client accessing encrypted data in the cloud. The functionality of hiding the access pattern is trivially solvable by having the client access all items, giving a linear overhead. However, to be considered an \acrshort{oram} protocol, it has to have a non-trivial solution, thus sublinear overhead.

We look at the adversarial modeling in \acrshort{oram} to understand what \acrshort{oram} guarantees. ``We consider an "adversary" who can monitor communication between $\text{CPU}_k$ and $\text{RAM}_k$ (but can not monitor conversations between either $\text{CPU}_k$ and "program" or between $\text{CPU}_k$ and random oracle.) The goal of the "adversary" is to learn as much information about the request sequence as
possible.'' \cite{STOC:Ostrovsky90} Effectively, the adversary is an outside observer of the communication, where there is no guarantee for the privacy of the \acrshort{cpu} with respect to the \acrshort{ram} and vice versa. Distinctly, this implies that \acrshort{oram} is only concerned with hiding how data is accessed, not the data itself; therefore, in many cases, it is implicit that the data stored is encrypted, allowing us to shift the adversary from an outside observer to be residing with the stored data. 

If we consider this more modern view, we can rephrase the goal of \acrshort{oram} to suit our problem better. \acrshort{oram} hides a client's access pattern on encrypted data from the server where the data is stored. We take a step back, and note that this only implies privacy for the client, and in our case, we need it both ways. The protocol presented in \cref{sec:databaseinitiation} and \cref{sec:recordretrieval} is inspired by the classical \acrshort{oram} protocol \cite{GolOst96}, referred to as square-root \acrshort{oram}, by its use of oblivious sorting and dummy items. In it, we provide two-way privacy, effectively transforming it into an \acrshort{ot} scheme, but one caveat is that we cannot provide sublinear data writing. In \acrshort{oram}, the client can both read and write data to the server in sublinear complexity; this is due to the data being generated by the client, and the server merely acts as a storage device.
On the contrary, in our case, the server generates the data. To see why this is so different, let us imagine that we have initiated the \acrshort{oram} by obliviously shuffling and encrypting the data on the server under the client's conditions. If the server wants to add some new record to that structure, using some sublinear number of accesses by the client, it would tell the server that the new record exists among these few records that it accessed. Given $ n $ number of records, we want the server to have a $ \frac{1}{n} $ probability of guessing right. Thus, inserting a new record requires at least a linear number of accesses, thereby effectively making the insertion problem equivalent in magnitude to initiating the structure in the first place.   
