Our core objective is to demonstrate feasibility. Therefore, along the way, we have implemented the proposed solutions as programs and used them in experiments to extract metrics like runtime and total communication costs. So far, it might seem like these programs are stand-alone implementations, but they are, in fact, subprograms in one large complete implementation. We refer to this complete implementation as the program, and it consists of over 6000 lines of code (including docstrings) that features include the proof of concept (\cref{chap:protocolFromMPC}) application and private database search (\cref{chap:SolutionPDS}) application.

\section{Program Implementation}

We recall from the experimental setup, \cref{sec:experimentalsetup}, that we use Python 3.10 as our primary programming language and MP-SPDZ 0.3.8 to perform generic \acrshort{mpc}. In \cref{sec:proofofconceptResults} we discovered that semi-party.x gave us the quickest runtime, therefore, we instantiate MP-SPDZ with it. For communication outside MP-SPDZ, we use the socket library, a part of core Python, to establish a secure channel using \acrfull{tls} 1.3. To integrate MP-SPDZ with Python, the client and server write their input to separate local files that MP-SPDZ reads; once the computation is complete, MP-SPDZ writes the output in an output file located in the directory of the party that should learn it. Then, that file is read in Python to retrieve the output. This means that all communication between the client and server goes through either the secure communication channel or MP-SPDZ, which makes the parties independent, allowing them to persist on different systems and communicate over Ethernet / \acrfull{ip}. 

Once the client and server are online, the client can choose whether to perform a semantic search or keyword search. The client can also choose whether or not to continue from the previous session, thereby allowing the parties to preprocess the initiation phase, then go offline and return online later to perform the transfers without having to redo the initiation.

We have split the program into two phases: the initiation and the transfer phases. The initiation is done once, and once complete, we can perform $ k $ number of transfers constrained by the number of dummy records in the database.

In the initiation, the database and either the keyword search or semantic search are initialized, depending on the client's choice at the beginning. The idea in the database initiation is for the client to shuffle and encrypt the database obliviously. First, the server fills the database with new records, \cref{sec:MockPassengerNumberRecords}, and pads them by implementing \cref{algo:DatabasePadding}. Crucially, the order of the indices on the records are randomly shuffled. Then, the client and server perform the shuffling and encryption of the records by implementing \cref{algo:ClientPreProcess} and \cref{algo:ServerPreProcess}, where we implemented $ \Sort $ as bitonic sort, $ \Permute $ with the core Python library random, use the generic MPC-based \acrshort{ps} protocol, \cref{algo:ClientBooleanPS} and \cref{algo:ServerBooleanPS}, and to generate key streams we use $ \CTR$-$\Encrypt $ as \acrshort{ctr}-\acrshort{aes}, provided to use by the cryptography library \cite{pycaCryptography}. $ \KeyGen $ is implemented by getting random bit strings from /dev/urandom to produce nonces and encryption keys. Next, either the keyword search or semantic search is initiated.

 In the case of the keyword search, the server creates and encrypts an inverted index matrix where it enforces access control by filtering unwanted information when reading the records. To do this, the server implements \cref{algo:Filter} and \cref{algo:Garble}, we use $ \Hash $ as \acrshort{shake} and $ \Encrypt $ as \acrshort{aes}, both of which are provided by the cryptography library. 

In the case of the semantic search, the server creates an indexing containing vector embeddings of each record. It does so by implementing \cref{algo:SemanticFilter}, and $ \Gamma $ we use the all-mpnet-base-v2 model from \acrfull{sbert} \cite{reimers-2019-sentence-bert}. 

The communication flow between the client and server in the initiation implements \cref{fig:OverviewPreProcess}, \cref{fig:OverviewInitKeywordSearch} and \cref{fig:OverviewInitSemanticSearch}, respectively.

In the transfer(s), the database search and record retrieval are executed. In the case of the keyword search, the client gets its search query encrypted under the server's keys, then performs the lookup of the encrypted inverted index matrix and decrypts one row, reavling a set of indices. The client, therefore, implements \cref{algo:ClientSearch}, with $ \Decrypt $ as \acrshort{aes} provided by the cryptography library, and the server implements \cref{algo:ServerSearch}. For both algorithms $ \Encrypt $ uses the \acrshort{aes} circuit provided with MP-SPDZ. In the case of the semantic search, the client and server together compute the distances between the search query and all the vector embeddings, then return the indices of embeddings that are closer than some threshold. This is achieved by the client implementing \cref{algo:ClientSemanticSearch} and the server implementing \cref{algo:ServerSemanticSearch}; we use Euclidean distance for $ \Distance $.

Once the search is complete, the client wants to retrieve the records corresponding to the indices it learned. To do so, it implements \cref{algo:Encode}, where $ \Encode $ uses the permutation, that it used to shuffle the database, to translate the indices to their new location, and pads it to a fixed length using dummy record indices. Then, the server implements \cref{algo:Retrieve}, which collects the encrypted records for the encoded indices. Lastly, the client implements \cref{algo:Decode}, where $ \Decode $ reproduces the key stream with \acrshort{ctr}-\acrshort{aes}, provided by the cryptography library, to decrypt each record.

The communication flow between the client and server implements \cref{fig:OverviewTransferKeywordSearch}, \cref{fig:OverviewTransferSemanticSearch} and \cref{fig:OverviewRetrieve}, respectively.

\hfill

\noindent
Limitations in the implementation:
\begin{itemize}
    \item The mock records' itinerary does not have to include a Norwegian airport.
    \item The X.509 certificates are not signed by a trusted \acrfull{ca}, but rather self-signed; therefore, the client and server's certificates are manually added as trusted by each other to enable authentication in \acrshort{tls}.
    \item For demonstrative purposes the semantic search returns the whole array of indices and distances to the client, then the client always picks the closes record to retrieve regardless of its distance. A simplification done as the \acrshort{llm} is not trained on mock records and is therefore not accurate.
\end{itemize}

The final experiment demonstrates that the program allows the client to perform private searches on a mock \acrshort{pnr} registry, it was performed in February 2024 with members from Kripos and other competent authorities present. We showcased how this program with the keyword search is feasible to use in an investigation and discussed some of the challenges surrounding research, development, and legislative compliance. For those who were not present, similar experiments can be recreated as the entire program is made public on \url{https://github.com/BenjaminHansenMortensen/PrivateDatabaseSearch}. \footnote{We do not make any security guarantees, as this implementation is intended for private and demonstrative use.}