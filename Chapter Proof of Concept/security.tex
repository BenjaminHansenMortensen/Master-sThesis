\section{Security}
\label{sec:proofofconceptSecurity}
%\addcontentsline{toc}{section}{Security}

Recall that we implemented $ \Search $ and $ \Retrieve $ as a program in MP-SPDZ. Therefore, security boils down to the security of the underlying generic \acrshort{mpc} protocol, its implementation in MP-SPDZ, and the overall security of MP-SPDZ. These things are subject to change and are, therefore, out of the scope of this work. Instead, let us talk about the deviations from the desired functionality and additional risks not captured by it. We relate the program to our notion of privacy, discuss the information leakage in our program and finish with a discussion on an important practical implication, namely false positives, and propose mitigations to it.  

For security, we want to protect against semi-honest adversaries. We are only concerned with a client and a server, so only two parties are involved, which means that if either party is dishonest, any protocol that assumes an honest majority is not sufficient. To model our parties, we instantiate them as an independent process whose only communication is through the interface MP-SPDZ. The only values that the client sees are $ q $ and $ F $, and the server only sees $ A $ and $ D $. We assume that the underlying generic \acrshort{mpc} protocol provides semantic security, our privacy notion holds as the server does learn anything about the query and the result, while the client only learns the result.

\refstepcounter{subsection}\subsection*{\thesubsection\quad Information Leakage}\label{subsec:ProofOfConceptInformationLeakage}


Regarding the program's output, it is not enough to consider the actual values revealed as the only information revealed to the client, as context and structure could also leak unwanted information. Here, we exclude all information in the records from the assessment and side channel leaks.

There is only one output of the program, which is revealed to the client. That output $ F $ has the same structure as the database input from the server, so it leaks the following information: 1) How many records, $ m $, there are since the number of rows it has is directly correlated to $ m $. A simple solution to avoid this is to pad the database to a fixed length. However, this would be costly in terms of adding redundant computations while being ineffective, as the magnitude of the number of records is still revealed. 2) The indices of the retrieved records. These can be used to deduce further information. For example, combining results from multiple searches can be used to infer deletion and creation of new records. A solution to avoid this is by shuffling the order in which the records are read. 3) The value of $ \omega $, which is intrinsic to the program's description.

\refstepcounter{subsection}\subsection*{\thesubsection\quad False Positives}\label{subsec:False Positives}

In the computation, we define a matching of the search query and a record if the digest of the search query is equal to the digest of one of the values in the record. It follows from using a cryptographically secure hash function that we do not get false positives in this matching, so that is not a concern, but what is a concern is the input-space to the hash function, as many of the values in the record have a small range. For example, the set of phone numbers, excluding prefixes, is small. This small input space could lead to false positives. An even better example is that some people have the same names. A solution to mitigate this weakness is for the server to filter keys and values when creating the indexing of the records, so the client has to provide sufficient evidence to satisfy the search criteria. A potential solution is to extend the search to allow the client to provide a set of inputs for the search query, which is combined to determine if the client has provided sufficient evidence. Like a scoring system, where a positive match to some values in the records is worth more than others, and in the end, the amount of information the client receive depends on the accumulated score.
